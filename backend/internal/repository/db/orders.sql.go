// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: orders.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (user_id, delivery_address, delivery_date, notes, payment_method, total_amount)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, delivery_address, delivery_date, notes, payment_method, status, total_amount, created_at, updated_at
`

type CreateOrderParams struct {
	UserID          uuid.UUID      `json:"user_id"`
	DeliveryAddress string         `json:"delivery_address"`
	DeliveryDate    time.Time      `json:"delivery_date"`
	Notes           pgtype.Text    `json:"notes"`
	PaymentMethod   string         `json:"payment_method"`
	TotalAmount     pgtype.Numeric `json:"total_amount"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.UserID, arg.DeliveryAddress, arg.DeliveryDate,
		arg.Notes, arg.PaymentMethod, arg.TotalAmount,
	)
	var o Order
	err := row.Scan(
		&o.ID, &o.UserID, &o.DeliveryAddress, &o.DeliveryDate,
		&o.Notes, &o.PaymentMethod, &o.Status, &o.TotalAmount,
		&o.CreatedAt, &o.UpdatedAt,
	)
	return o, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (order_id, product_id, quantity, unit_price, total_price)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, order_id, product_id, quantity, unit_price, total_price, created_at
`

type CreateOrderItemParams struct {
	OrderID    uuid.UUID      `json:"order_id"`
	ProductID  uuid.UUID      `json:"product_id"`
	Quantity   int32          `json:"quantity"`
	UnitPrice  pgtype.Numeric `json:"unit_price"`
	TotalPrice pgtype.Numeric `json:"total_price"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.OrderID, arg.ProductID, arg.Quantity, arg.UnitPrice, arg.TotalPrice,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID, &i.OrderID, &i.ProductID, &i.Quantity,
		&i.UnitPrice, &i.TotalPrice, &i.CreatedAt,
	)
	return i, err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT id, user_id, delivery_address, delivery_date, notes, payment_method, status, total_amount, created_at, updated_at
FROM orders WHERE id = $1 AND user_id = $2
`

func (q *Queries) GetOrderByID(ctx context.Context, id, userID uuid.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByID, id, userID)
	var o Order
	err := row.Scan(
		&o.ID, &o.UserID, &o.DeliveryAddress, &o.DeliveryDate,
		&o.Notes, &o.PaymentMethod, &o.Status, &o.TotalAmount,
		&o.CreatedAt, &o.UpdatedAt,
	)
	return o, err
}

const listOrdersByUserID = `-- name: ListOrdersByUserID :many
SELECT id, user_id, delivery_address, delivery_date, notes, payment_method, status, total_amount, created_at, updated_at
FROM orders WHERE user_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

func (q *Queries) ListOrdersByUserID(ctx context.Context, userID uuid.UUID, limit, offset int32) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrdersByUserID, userID, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var orders []Order
	for rows.Next() {
		var o Order
		if err := rows.Scan(
			&o.ID, &o.UserID, &o.DeliveryAddress, &o.DeliveryDate,
			&o.Notes, &o.PaymentMethod, &o.Status, &o.TotalAmount,
			&o.CreatedAt, &o.UpdatedAt,
		); err != nil {
			return nil, err
		}
		orders = append(orders, o)
	}
	return orders, rows.Err()
}

const countOrdersByUserID = `-- name: CountOrdersByUserID :one
SELECT COUNT(*) FROM orders WHERE user_id = $1
`

func (q *Queries) CountOrdersByUserID(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countOrdersByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

// GetOrderItemsRow joins order_items with product name and image.
type GetOrderItemsRow struct {
	OrderItem
	ProductName     string      `json:"product_name"`
	ProductImageUrl pgtype.Text `json:"product_image_url"`
}

const getOrderItems = `-- name: GetOrderItems :many
SELECT oi.id, oi.order_id, oi.product_id, oi.quantity, oi.unit_price, oi.total_price, oi.created_at,
       p.name AS product_name, p.image_url AS product_image_url
FROM order_items oi JOIN products p ON p.id = oi.product_id
WHERE oi.order_id = $1
`

func (q *Queries) GetOrderItems(ctx context.Context, orderID uuid.UUID) ([]GetOrderItemsRow, error) {
	rows, err := q.db.Query(ctx, getOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var items []GetOrderItemsRow
	for rows.Next() {
		var i GetOrderItemsRow
		if err := rows.Scan(
			&i.ID, &i.OrderID, &i.ProductID, &i.Quantity,
			&i.UnitPrice, &i.TotalPrice, &i.CreatedAt,
			&i.ProductName, &i.ProductImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	return items, rows.Err()
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders SET status = $2, updated_at = NOW() WHERE id = $1
RETURNING id, user_id, delivery_address, delivery_date, notes, payment_method, status, total_amount, created_at, updated_at
`

func (q *Queries) UpdateOrderStatus(ctx context.Context, id uuid.UUID, status string) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderStatus, id, status)
	var o Order
	err := row.Scan(
		&o.ID, &o.UserID, &o.DeliveryAddress, &o.DeliveryDate,
		&o.Notes, &o.PaymentMethod, &o.Status, &o.TotalAmount,
		&o.CreatedAt, &o.UpdatedAt,
	)
	return o, err
}
