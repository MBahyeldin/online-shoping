// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: otps.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createOTP = `-- name: CreateOTP :one
INSERT INTO email_otps (user_id, otp_hash, expires_at)
VALUES ($1, $2, $3)
RETURNING id, user_id, otp_hash, expires_at, is_used, attempt_count, created_at
`

type CreateOTPParams struct {
	UserID    uuid.UUID `json:"user_id"`
	OtpHash   string    `json:"otp_hash"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) CreateOTP(ctx context.Context, arg CreateOTPParams) (EmailOtp, error) {
	row := q.db.QueryRow(ctx, createOTP, arg.UserID, arg.OtpHash, arg.ExpiresAt)
	var o EmailOtp
	err := row.Scan(&o.ID, &o.UserID, &o.OtpHash, &o.ExpiresAt, &o.IsUsed, &o.AttemptCount, &o.CreatedAt)
	return o, err
}

const getLatestOTPByUserID = `-- name: GetLatestOTPByUserID :one
SELECT id, user_id, otp_hash, expires_at, is_used, attempt_count, created_at
FROM email_otps WHERE user_id = $1 ORDER BY created_at DESC LIMIT 1
`

func (q *Queries) GetLatestOTPByUserID(ctx context.Context, userID uuid.UUID) (EmailOtp, error) {
	row := q.db.QueryRow(ctx, getLatestOTPByUserID, userID)
	var o EmailOtp
	err := row.Scan(&o.ID, &o.UserID, &o.OtpHash, &o.ExpiresAt, &o.IsUsed, &o.AttemptCount, &o.CreatedAt)
	return o, err
}

const markOTPUsed = `-- name: MarkOTPUsed :exec
UPDATE email_otps SET is_used = TRUE WHERE id = $1
`

func (q *Queries) MarkOTPUsed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markOTPUsed, id)
	return err
}

const incrementOTPAttempts = `-- name: IncrementOTPAttempts :one
UPDATE email_otps SET attempt_count = attempt_count + 1
WHERE id = $1 RETURNING id, user_id, otp_hash, expires_at, is_used, attempt_count, created_at
`

func (q *Queries) IncrementOTPAttempts(ctx context.Context, id uuid.UUID) (EmailOtp, error) {
	row := q.db.QueryRow(ctx, incrementOTPAttempts, id)
	var o EmailOtp
	err := row.Scan(&o.ID, &o.UserID, &o.OtpHash, &o.ExpiresAt, &o.IsUsed, &o.AttemptCount, &o.CreatedAt)
	return o, err
}

const countRecentOTPsByUserID = `-- name: CountRecentOTPsByUserID :one
SELECT COUNT(*) FROM email_otps
WHERE user_id = $1 AND created_at > NOW() - INTERVAL '1 hour'
`

func (q *Queries) CountRecentOTPsByUserID(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countRecentOTPsByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const invalidateUserOTPs = `-- name: InvalidateUserOTPs :exec
UPDATE email_otps SET is_used = TRUE WHERE user_id = $1 AND is_used = FALSE
`

func (q *Queries) InvalidateUserOTPs(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, invalidateUserOTPs, userID)
	return err
}
